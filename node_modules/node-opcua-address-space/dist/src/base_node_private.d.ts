import { LocalizedText, NodeClass } from "node-opcua-data-model";
import { NodeId, NodeIdLike } from "node-opcua-nodeid";
import { ReferenceDescription } from "node-opcua-types";
import { AddressSpace, SessionContext, UAObjectType as UAObjectTypePublic, UAObject as UAObjectPublic, ModellingRuleType } from "../source";
import { BaseNode as BaseNodePublic } from "../source";
import { BaseNode } from "./base_node";
import { Reference } from "./reference";
import { UAMethod } from "./ua_method";
import { UAObject } from "./ua_object";
import { UAObjectType } from "./ua_object_type";
import { UAVariable } from "./ua_variable";
import { UAVariableType } from "./ua_variable_type";
import { Namespace } from "../source";
import { QualifiedName } from "node-opcua-data-model";
interface BaseNodeCache {
    __address_space: AddressSpace | null;
    _browseFilter?: (this: BaseNode, context?: SessionContext) => boolean;
    _cache: any;
    _description?: LocalizedText;
    _displayName: LocalizedText[];
    _parent?: BaseNodePublic | null;
    _back_referenceIdx: {
        [key: string]: Reference;
    };
    _referenceIdx: {
        [key: string]: Reference;
    };
    _subtype_idxVersion: number;
    _subtype_idx: any;
}
export declare function BaseNode_initPrivate(self: BaseNode): BaseNodeCache;
export declare function BaseNode_removePrivate(self: BaseNode): void;
export declare function BaseNode_getPrivate(self: BaseNode): BaseNodeCache;
export declare function BaseNode_getCache(node: BaseNode): any;
export declare function BaseNode_clearCache(node: BaseNode): void;
export interface ToStringOption {
    level: number;
    cycleDetector: any;
    padding: string;
    add(someLine: string): void;
    indent(a: string, b: string | null): void;
}
export declare class ToStringBuilder implements ToStringOption {
    level: number;
    cycleDetector: any;
    padding: string;
    private str;
    constructor();
    add(line: string): void;
    toString(): string;
    indent(str: string, padding: string | null): string;
}
export declare function BaseNode_toString(this: BaseNode, options: ToStringOption): void;
export declare function BaseNode_References_toString(this: BaseNode, options: ToStringOption): void;
export declare function UAVariableType_toString(this: UAVariableType, options: ToStringOption): void;
export declare function UAVariable_toString(this: UAVariable, options: ToStringOption): void;
export declare function UAObject_toString(this: UAObject, options: ToStringOption): void;
export declare function UAObjectType_toString(this: UAObjectType, options: ToStringOption): void;
export declare function valueRankToString(valueRank: number): string;
export declare function VariableOrVariableType_toString(this: UAVariableType | UAVariable, options: ToStringOption): void;
export declare type CloneExtraInfo = any;
export interface CloneFilter {
    shouldKeep(node: BaseNodePublic): boolean;
    filterFor(childInstance: UAVariableType): CloneFilter;
}
export declare function _clone_children_references(this: BaseNodePublic, newParent: BaseNodePublic, optionalFilter?: CloneFilter, extraInfo?: CloneExtraInfo): void;
export declare function _clone_non_hierarchical_references(this: BaseNode, newParent: BaseNodePublic, optionalFilter?: CloneFilter, extraInfo?: CloneExtraInfo): void;
export interface CloneOptions {
    namespace: Namespace;
    references?: Reference[];
    nodeId?: string | NodeIdLike | null;
    nodeClass?: NodeClass;
    browseName?: QualifiedName;
    descriptions?: LocalizedText;
    modellingRule?: ModellingRuleType;
    accessLevel?: number;
    arrayDimensions?: number[] | null;
    dataType?: NodeId;
    historizing?: boolean;
    minimumSamplingInterval?: number;
    userAccessLevel?: number;
    valueRank?: number;
    eventNotifier?: number;
    symbolicName?: string;
    executable?: boolean;
    methodDeclarationId?: NodeId;
    componentOf?: UAObjectTypePublic | UAObjectPublic;
}
/**
 * @method _clone
 * @private
 */
export declare function _clone<T extends UAObject | UAVariable | UAMethod>(this: T, Constructor: any, options: CloneOptions, optionalFilter?: CloneFilter, extraInfo?: CloneExtraInfo): T;
export declare function _handle_HierarchicalReference(node: BaseNode, reference: Reference): void;
export declare function _constructReferenceDescription(addressSpace: AddressSpace, references: Reference[], resultMask: number): ReferenceDescription[];
export declare function BaseNode_remove_backward_reference(this: BaseNode, reference: Reference): void;
export declare function BaseNode_add_backward_reference(this: BaseNode, reference: Reference): void;
export declare function apply_condition_refresh(this: BaseNode, _cache?: any): void;
export {};
