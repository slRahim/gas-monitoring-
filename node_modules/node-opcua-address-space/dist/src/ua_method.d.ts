import { AttributeIds } from "node-opcua-data-model";
import { NodeClass } from "node-opcua-data-model";
import { DataValue } from "node-opcua-data-value";
import { NodeId } from "node-opcua-nodeid";
import { Argument } from "node-opcua-service-call";
import { CallMethodResultOptions } from "node-opcua-types";
import { VariantLike } from "node-opcua-variant";
import { MethodFunctor, MethodFunctorCallback, UAMethod as UAMethodPublic, UAObject as UAObjectPublic } from "../source";
import { SessionContext } from "../source";
import { BaseNode } from "./base_node";
import { CloneExtraInfo, CloneFilter, CloneOptions } from "./base_node_private";
import { UAObject } from "./ua_object";
import { UAObjectType } from "./ua_object_type";
export declare class UAMethod extends BaseNode implements UAMethodPublic {
    static checkValidArgument(args: any): boolean;
    readonly nodeClass = NodeClass.Method;
    get typeDefinitionObj(): UAObjectType;
    get parent(): UAObjectPublic | null;
    value?: any;
    methodDeclarationId: NodeId;
    _getExecutableFlag?: (this: UAMethod, context: SessionContext) => boolean;
    _asyncExecutionFunction?: MethodFunctor;
    constructor(options: any);
    /**
     *
     *
     */
    getExecutableFlag(context: SessionContext): boolean;
    /**
     *
     * @returns  true if the method is bound
     */
    isBound(): boolean;
    readAttribute(context: SessionContext, attributeId: AttributeIds): DataValue;
    getInputArguments(): Argument[];
    getOutputArguments(): Argument[];
    bindMethod(async_func: MethodFunctor): void;
    execute(object: UAObject | UAObjectType | null, inputArguments: null | VariantLike[], context: SessionContext): Promise<CallMethodResultOptions>;
    execute(object: UAObject | UAObjectType | null, inputArguments: null | VariantLike[], context: SessionContext, callback: MethodFunctorCallback): void;
    clone(options: CloneOptions, optionalFilter?: CloneFilter, extraInfo?: CloneExtraInfo): UAMethodPublic;
    private _getArguments;
}
