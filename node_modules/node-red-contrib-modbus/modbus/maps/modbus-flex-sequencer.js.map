{"version":3,"sources":["modbus-flex-sequencer.js"],"names":["module","exports","RED","require","install","mbCore","mbIOCore","nodes","registerType","config","createNode","this","name","sequences","internalDebugLog","showStatusActivities","showErrors","connection","ModbusFlexSequencer","useIOFile","ioFile","getNode","useIOForPayload","logIOActivities","keepMsgProperties","node","mbBasics","verboseLogging","verbose","bufferMessageList","Map","server","modbusClient","initModbusClientEvents","onModbusReadDone","resp","msg","data","buildMessageWithIO","logMsgError","err","sendEmptyMsgOnFail","origMsg","getOriginalMessage","errorProtocolMsg","onModbusReadError","setModbusError","JSON","parse","fc","unitid","parseInt","address","quantity","isValidModbusMsg","Number","isInteger","isValid","error","buildNewMessageObject","topic","messageId","payload","id","emptyMsgOnFail","on","client","seq","invalidSequencesIn","origMsgInput","Object","assign","m","inputMsg","newMsg","set","emit","setNodeStatusTo","actualServiceState","clear","deregisterForModbus","done","setNodeDefaultStatus"],"mappings":"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","file":"../modbus-flex-sequencer.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n@author <a>Andrea Verardi</a> (Anversoft)\n */\n/**\n * Modbus Getter node.\n * @module NodeRedModbusFlexSequencer\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const mbIOCore = require('./core/modbus-io-core')\n  const internalDebugLog = require('debug')('contribModbus:poller')\n\n  function ModbusFlexSequencer (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.sequences = config.sequences\n\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.keepMsgProperties = config.keepMsgProperties\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n    node.bufferMessageList = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('reading done', node)\n      }\n\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\n      node.emit('modbusFlexGetterNodeDone')\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      mbBasics.logMsgError(node, err, msg)\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      node.internalDebugLog(err.message)\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\n      node.errorProtocolMsg(err, origMsg)\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\n      node.emit('modbusFlexGetterNodeError')\n    }\n\n    node.prepareMsg = function (msg) {\n      if (typeof msg === 'string') {\n        msg = JSON.parse(msg)\n      }\n\n      switch (msg.fc) {\n        case 'FC1':\n          msg.fc = 1\n          break\n        case 'FC2':\n          msg.fc = 2\n          break\n        case 'FC3':\n          msg.fc = 3\n          break\n        case 'FC4':\n          msg.fc = 4\n          break\n      }\n\n      msg.unitid = parseInt(msg.unitid)\n      msg.address = parseInt(msg.address) || 0\n      msg.quantity = parseInt(msg.quantity) || 1\n\n      return msg\n    }\n\n    node.isValidModbusMsg = function (msg) {\n      let isValid = true\n\n      if (!(Number.isInteger(msg.unitid) &&\n          msg.unitid >= 1 &&\n          msg.unitid <= 255)) {\n        node.error('Unit ID Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n        !(Number.isInteger(msg.address) &&\n          msg.address >= 0 &&\n          msg.address <= 65535)) {\n        node.error('Address Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n        !(Number.isInteger(msg.quantity) &&\n          msg.quantity >= 1 &&\n          msg.quantity <= 65535)) {\n        node.error('Quantity Not Valid', msg)\n        isValid &= false\n      }\n\n      return isValid\n    }\n\n    node.buildNewMessageObject = function (node, msg) {\n      const messageId = mbCore.getObjectId()\n      return {\n        topic: msg.topic || node.id,\n        messageId,\n        payload: {\n          name: msg.name,\n          unitid: msg.unitid,\n          fc: msg.fc,\n          address: msg.address,\n          quantity: msg.quantity,\n          emptyMsgOnFail: node.emptyMsgOnFail,\n          keepMsgProperties: node.keepMsgProperties,\n          messageId\n        }\n      }\n    }\n\n    node.on('input', function (msg) {\n      // Se il client Ã¨ nullo non eseguire niente\n      if (!modbusClient.client) {\n        return\n      }\n      // Copia le sequenze in una costante, se msg contiene sequences allora esegui l'override\n      const seq = mbBasics.invalidSequencesIn(msg) ? node.sequences : msg.sequences\n\n      // Mantieni l'origine\n      const origMsgInput = Object.assign({}, msg)\n\n      try {\n        for (const m in seq) {\n          const inputMsg = node.prepareMsg(seq[m])\n          if (node.isValidModbusMsg(inputMsg)) {\n            const newMsg = node.buildNewMessageObject(node, inputMsg)\n            node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, inputMsg, newMsg))\n            modbusClient.emit('readModbus', newMsg, node.onModbusReadDone, node.onModbusReadError)\n          }\n        }\n      } catch (err) {\n        node.errorProtocolMsg(err, origMsgInput)\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-flex-sequencer', ModbusFlexSequencer)\n}\n"]}